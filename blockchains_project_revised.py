# -*- coding: utf-8 -*-
"""Blockchains Project - Revised.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14ZRp-XkvocS7S6vCpkDa3tPmer6hp97D
"""

"""
    References

    Libraries Used in the Project:
    1.  pycryptodome: used the DSA, DSS, and SHA512 modules from this library to implement digital signatures.
        (install using pip install pycryptodomex OR conda install pycryptodomex)
    2.  json: used to save the files in the json format.
    3.  random: used for the randomized simulator.
    4.  decimal: used for accurate monetary arithmetic.

    Assumptions and Design
    
    Notes
        1.  Coin Ids are (Transaction Id, Coin Serial Number).
        2.  Transaction amount is the sum of the values of the coins created in the transaction. 
            (Not stored explicitly, but amount is specified for each receiver)
        3.  Each transaction may have two recipients: the receiver gets the payment, the payer gets the remainder.
        4.  The simulator allows you to generate random valid transactions.
        5.  The simulator allows you to generate random attacks.
        6.  The simulation assumes that the blockchain is secure all the time.
        7.  The simulation assumes that there is no need to print the initial scrooge coin creation transactions (There are 100)
"""

# !pip install pycryptodomex

from Cryptodome.PublicKey import DSA
from Cryptodome.Signature import DSS
from Cryptodome.Hash import SHA512
import json
import random
from decimal import *
getcontext().prec = 28
random.seed(0)
SIZE_BLOCK = 10
NUMBER_OF_USERS = 100

def print_console_and_file(output):
    print(output)
    with open('output.txt', 'a') as file_out:
        print(output, file=file_out)

class Hash_Pointer:
    def __init__(self, pointer, hash_value, coin_serial_num=None):
        self.__hash_value = hash_value
        self.__pointer = pointer
        self.__coin_serial_num = coin_serial_num
    
    def get_hash_value(self):
        return self.__hash_value
    
    def get_pointer(self):
        return self.__pointer
    
    def get_coin_serial_num(self):
        return self.__coin_serial_num
    
    def equals(self, other_hash_pointer):
        return (
            self.get_pointer() is other_hash_pointer.get_pointer()
            ) and (
                self.get_hash_value() == other_hash_pointer.get_hash_value()
                ) and (
                    self.get_coin_serial_num() == other_hash_pointer.get_coin_serial_num()
                    )

class Transaction:
    def __init__(self, transaction_type, consumed_coins_ids, values, recepients):
        self.transaction_id = str(self)
        self.transaction_type = transaction_type

        self.consumed_coins_ids = consumed_coins_ids

        if len(values) != len(recepients):
            raise Exception('The number of coins and recepients is not equal')
        
        self.coins_created = {}
        for serial_num in range(len(values)):
            self.coins_created[serial_num] = {
                'value': values[serial_num],
                'recepient': recepients[serial_num]
            }
    
    def generate_slip(self, asdict=False):
        slip = {}
        slip['id'] = str(self)
        slip['type'] = self.transaction_type
        
        slip['coins_consumed'] = {}
        for index in range(len(self.consumed_coins_ids)):
            slip['coins_consumed'][index] = {
                'transaction_id': str(self.consumed_coins_ids[index].get_pointer()),
                'transaction_hash': self.consumed_coins_ids[index].get_hash_value().hexdigest(),
                'coin_serial_number': self.consumed_coins_ids[index].get_coin_serial_num()
            }

        slip['coins_created'] = {}
        for index in range(len(self.coins_created)):
            slip['coins_created'][index] = {
                'value': str(self.coins_created[index]['value']),
                'recepient': self.coins_created[index]['recepient'].export_key().decode()
            }
        
        if asdict:
            return slip
        else:
            return json.dumps(slip, indent=4, ensure_ascii=False)
    
    def add_signature(self, signature):
        self.signature = signature
    
    def get_signature(self):
        return self.signature

class Block:

    def __init__(self, transactions, previous_block_hash_pointer):
        self.__transactions = transactions
        self.__block_id = str(self)
        self.__previous_block_hash_pointer = previous_block_hash_pointer
    
    def get_id(self):
        return self.__block_id

    def get_previous_hash_pointer(self):
        return self.__previous_block_hash_pointer

    def generate_slip(self, as_dict=False):
        slip = {}

        slip['block_id'] = self.__block_id
        slip['previous_block_pointer'] = str(self.__previous_block_hash_pointer.get_pointer())
        slip['previous_block_hash_value'] = self.__previous_block_hash_pointer.get_hash_value()
        
        slip['transactions'] = {}
        for index in range(len(self.__transactions)):
            slip['transactions'][index] = {
                'transaction_body': self.__transactions[index].generate_slip(asdict=True),
                'signature': str(self.__transactions[index].signature)
            }

        if as_dict:
            return slip
        else:
            return json.dumps(slip, sort_keys=False, indent=4, ensure_ascii=False)
    
    def add_hash_value(self, hash_value):
        self.__hash_value = hash_value
    
    def get_hash_value(self):
        return self.__hash_value
    
    def get_transactions(self):
        return self.__transactions

class Blockchain:
    def __init__(self):
        self.final_hash_pointer = Hash_Pointer(None, None)
        self.final_block_scrooge_signature = None

    def add_block(self, block, hash_value, signature):
        self.final_hash_pointer = Hash_Pointer(block, hash_value)
        self.final_block_scrooge_signature = signature

    def generate_blockchain_string(self):

        data = {}

        data['final_block_hash_pointer'] = {
            'pointer': str(self.final_hash_pointer.get_pointer()),
            'hash': self.final_hash_pointer.get_hash_value(),
            'scrooge_signature': str(self.final_block_scrooge_signature)
        }

        block = self.final_hash_pointer.get_pointer()
        
        while block:
            data[block.get_id()] = block.generate_slip(as_dict=True)
            data[block.get_id()]['hash'] = block.get_hash_value()
            block = block.get_previous_hash_pointer().get_pointer()
        
        return json.dumps(data, sort_keys=False, indent=4, ensure_ascii=False)

class User:

    def __init__(self):
        self.ewallet = []
        self.spent_before = []

        self.ewallet_temp = []
        self.spent_before_temp = []

        self.__key = None
    
    def key_missing(self):
        return (self.__key is None)
    
    def get_id(self):
        if self.key_missing():
            self.generate_keys()
        return self.__key.publickey()
    
    def generate_keys(self):
        self.__key = DSA.generate(2048)

    def sign_transaction(self, transaction_slip):
        
        if self.key_missing():
            self.generate_keys()

        hash_obj = SHA512.new(transaction_slip.encode())
        signer = DSS.new(self.__key, 'fips-186-3')
        return signer.sign(hash_obj)
    
    def get_balance(self):
        payer_wallet = []
        
        for trans_hash_pointer in self.ewallet:
            spent = False
            
            for trans_hash_pointer_spent in self.spent_before:
                if trans_hash_pointer.equals(trans_hash_pointer_spent):
                    spent = True
            
            if not spent:
                payer_wallet.append(trans_hash_pointer)

        total = Decimal(0)
        for entry in payer_wallet:
            coins = entry.get_pointer().coins_created
            for serial_num in coins:
                if coins[serial_num]['recepient'].export_key() == self.get_id().export_key():
                    total += coins[serial_num]['value']

        return self.get_id().export_key(), total
    
    def notify_block_published(self):
        for x in self.spent_before_temp:
            self.spent_before.append(x)
        
        self.spent_before_temp = []
        
        for y in self.ewallet_temp:
            self.ewallet.append(y)
        
        self.ewallet_temp = []

class Scrooge:

    def __init__(self):
        self.__transactions = []
        self.blockchain = Blockchain()
        self.__scrooge_key = DSA.generate(2048)
        self.public_key = self.__scrooge_key.publickey()
    
    def __sign_transaction(self, transaction_slip):    
        hash_obj = SHA512.new(transaction_slip.encode())
        signer = DSS.new(self.__scrooge_key, 'fips-186-3')
        return signer.sign(hash_obj)
    
    def create_user_coins(self, users):
        for user in users:
            creation_transaction = Transaction(
                'CreateCoins',
                [],
                [Decimal(str(10))],
                [user.get_id()]
            )

            signature = self.__sign_transaction(creation_transaction.generate_slip())

            creation_transaction.add_signature(signature)

            user.ewallet.append(
                Hash_Pointer(
                    creation_transaction, 
                    SHA512.new(creation_transaction.get_signature()),
                    0
                    )
                )

            self.__transactions.append(creation_transaction)

            if len(self.__transactions) == SIZE_BLOCK: 
                self.__create_block()
                self.__transactions = []

    def add_transaction(self, transaction, payer):

        # Verify existence of coins and transactions and ownership of coins
        if not self.verify_existence(transaction, payer):
            return False, False
        
        # Verify signature
        if not self.verify_ownership(transaction, payer):
            print_console_and_file('ERROR: FAKE SIGNATURE DETECTED. TRANSACTION FAILED.')
            return False, False
        
        # Verify value
        if not self.verify_value(transaction):
            print_console_and_file('ERROR: DISCREPENCY IN COIN VALUES DETECTED. TRANSACTION FAILED.')
            return False, False
        
        # Verify double spending
        if not self.verify_double_spending(transaction, payer):
            return False, False
        
        print_console_and_file('LOG: VERIFICATION PASSED.')
        self.__transactions.append(transaction)
        
        slips_for_printing = [
                              transaction_to_print.generate_slip() 
                              for transaction_to_print in self.__transactions  
        ]
        signatures_for_printing = [
                                   json.dumps({'signature': str(transaction_to_print.get_signature())}, indent=4, ensure_ascii=False) 
                                   for transaction_to_print in self.__transactions
        ]
        
        ######PRINTING#########
        print_console_and_file('LOG: BLOCK UNDER CONSTRUCTION CONTAINS:')
        for slip_to_print, signature_to_print in zip(slips_for_printing, signatures_for_printing):
            print_console_and_file(slip_to_print)
            print_console_and_file(signature_to_print)
        #######################

        published_new_block = False
        if len(self.__transactions) == SIZE_BLOCK:
            self.__create_block()
            published_new_block = True
            self.__transactions = []
        
            ######PRINTING##########
            print_console_and_file('LOG: PRINTING BLOCKCHAIN')
            print_console_and_file(self.blockchain.generate_blockchain_string())
            print_console_and_file('LOG: PRINTING BLOCKCHAIN COMPLETE')
            ########################
        
        return True, published_new_block

    def __create_block(self):

        block = Block(self.__transactions, self.blockchain.final_hash_pointer)
        
        hash_obj = SHA512.new(block.generate_slip().encode())
        block.add_hash_value(hash_obj.hexdigest())
        signer = DSS.new(self.__scrooge_key, 'fips-186-3')
        signature = signer.sign(hash_obj)
        
        self.blockchain.add_block(block, hash_obj.hexdigest(), signature)
    
    def verify_existence(self, new_transaction, payer):
        consumed_coins_hash_pointers = new_transaction.consumed_coins_ids.copy()

        # ensure that all transactions exist in the blockchain
        block = self.blockchain.final_hash_pointer.get_pointer()
        
        while block:
            
            transactions = block.get_transactions()
            
            for trans_x in transactions:
                for hash_pointer in new_transaction.consumed_coins_ids:
                    # if transaction exists, and coin exists, and payer is the previous recepient, and transaction hash is valid
                    if (
                        trans_x is hash_pointer.get_pointer()
                        ) and (
                            hash_pointer.get_coin_serial_num() in trans_x.coins_created
                            ) and (
                                trans_x.coins_created[hash_pointer.get_coin_serial_num()]['recepient'].export_key() == payer.export_key()
                                ) and (
                                    SHA512.new(trans_x.get_signature()).hexdigest() == hash_pointer.get_hash_value().hexdigest()
                                ):
                        consumed_coins_hash_pointers.remove(hash_pointer)
                    
                    if len(consumed_coins_hash_pointers) == 0:
                        break
                
                if len(consumed_coins_hash_pointers) == 0:
                    break
            
            if len(consumed_coins_hash_pointers) == 0:
                break

            block = block.get_previous_hash_pointer().get_pointer()
        
        if len(consumed_coins_hash_pointers) != 0:
            print_console_and_file('ERROR: DECEPTION DETECTED. PREVIOUS TRANSACTIONS PROVIDED ARE FAULTY.')
            return False
        else:
            return True

    def verify_ownership(self, transaction, payer):
        public_key = payer
        verifier = DSS.new(public_key, 'fips-186-3')
        hash_obj = SHA512.new(transaction.generate_slip().encode())
        try:
            verifier.verify(hash_obj, transaction.get_signature())
            return True
        except ValueError:
            return False
    
    def verify_value(self, transaction):
        created_value = 0
        for serial_num in range(len(transaction.coins_created)):
            created_value += transaction.coins_created[serial_num]['value']
        
        consumed_value = 0
        for hash_pointer in transaction.consumed_coins_ids:
            consumed_value += hash_pointer.get_pointer().coins_created[hash_pointer.get_coin_serial_num()]['value']
        
        # check for duplicates
        if not (
            self.check_duplicates(transaction.consumed_coins_ids)
            ):
            return False
        else:
            return created_value == consumed_value

    def check_duplicates(self, consumed_coins_hash_pointers):
        for i in range(len(consumed_coins_hash_pointers)):
            for j in range(len(consumed_coins_hash_pointers)):
                if (i != j) and consumed_coins_hash_pointers[i].equals(consumed_coins_hash_pointers[j]):
                    print_console_and_file('ERROR: DUPLICATES FOUND IN TRANSACTION CONSUMED COINS.')
                    return False
        
        return True

    def verify_double_spending(self, new_transaction, payer):
        
        # ensure that all coins were not consumed before
        consumed_now_coins_hash_pointers = new_transaction.consumed_coins_ids.copy()
        
        block = self.blockchain.final_hash_pointer.get_pointer()
        
        while block:
            transactions = block.get_transactions()

            for trans_x in transactions:
                for consumed_now_hash_pointer in consumed_now_coins_hash_pointers:
                    for consumed_before_hash_pointer in trans_x.consumed_coins_ids:
                        if consumed_before_hash_pointer.equals(consumed_now_hash_pointer):
                            print_console_and_file('ERROR: DOUBLE SPENDING DETECTED. TRANSACTION FAILED.')
                            return False
            
            block = block.get_previous_hash_pointer().get_pointer()
        
        # check the temporary transactions
        for trans_x in self.__transactions:
            for consumed_now_hash_pointer in consumed_now_coins_hash_pointers:
                for consumed_before_hash_pointer in trans_x.consumed_coins_ids:
                    if consumed_before_hash_pointer.equals(consumed_now_hash_pointer):
                        print_console_and_file('ERROR: DOUBLE SPENDING DETECTED. TRANSACTION FAILED.')
                        return False

        return True

class RandomSimulator:
    
    def __init__(self, number_of_users):
        self.number_of_users = number_of_users
        self.users = [User() for value in range(number_of_users)]
        self.scrooge = Scrooge()
        print_console_and_file('LOG: SCROOGE IS CREATING COINS AND ADDING THEM TO THE BLOCKCHAIN')
        self.scrooge.create_user_coins(self.users)
        
        print_console_and_file('LOG: PRINTING USERS AND THEIR BALANCES')
        for user in self.users:
            print_console_and_file('ID:' + str(user.get_balance()[0]))
            print_console_and_file('BALANCE:' + str(user.get_balance()[1]))
        print_console_and_file('LOG: PRINTING USERS AND THEIR BALANCES COMPLETE')

    def get_random_valid_wallet(self):
        payer_wallet = []
        failure_counter = 0
        while len(payer_wallet) == 0:
            
            # To avoid infinite loops
            if failure_counter == 9999999:
                print_console_and_file(
                    """FAILURE: THE RANDOM SIMULATION REACHED A POINT WHERE NO VALID TRANSACTIONS ARE POSSIBLE. 
                    FAILURE: 9,999,999 trials to generate a new valid transaction failed."""
                    )
                raise Exception('FAILURE: NO VALID TRANSACTIONS ARE POSSIBLE. TERMINATED.')
            else:
                failure_counter += 1
            
            # retrieve payer and receiver
            [payer, receiver] = random.sample(self.users, 2)

            # generate payer wallet
            payer_wallet = []
            for trans_hash_pointer in payer.ewallet:
                spent = False
                
                for trans_hash_pointer_spent in payer.spent_before + payer.spent_before_temp:
                    if trans_hash_pointer.equals(trans_hash_pointer_spent):
                        spent = True
                
                if not spent:
                    payer_wallet.append(trans_hash_pointer)

        # print_console_and_file('#########PAYER WALLET#############')
        # print_console_and_file(payer.get_id().export_key()[-100:])
        # for slip in [x.get_pointer().generate_slip() for x in payer_wallet]:
        #     print_console_and_file(slip)
        # print_console_and_file('#########END PAYER WALLET#########')

        return payer, receiver, payer_wallet
    
    def generate_payment_from_wallet(self, payer, payer_wallet):
        """
        Generates a payment from random transaction hash pointers in the payer_wallet
        """

        transactions_used_as_basis = random.sample(payer_wallet, k=random.randint(1, len(payer_wallet)))
        
        greater_than = 0.01
        to_pay_cumulative = Decimal(str(0))
        to_keep_cumulative = Decimal(str(0))
        previous_transactions_hash_pointers = []
        for transaction_hash_pointer in transactions_used_as_basis:
            
            transaction = transaction_hash_pointer.get_pointer()

            # get total value in transaction
            value = Decimal(str(0))
            for serial_num in transaction.coins_created:
                if transaction.coins_created[serial_num]['recepient'].export_key() == payer.get_id().export_key():
                    value += transaction.coins_created[serial_num]['value']
                    previous_transactions_hash_pointers.append(
                        Hash_Pointer(
                            transaction_hash_pointer.get_pointer(), 
                            transaction_hash_pointer.get_hash_value(),
                            serial_num
                            )
                        )

            to_pay = Decimal(str(round(random.uniform(greater_than, float(value)), 2)))
            to_keep = value - to_pay

            to_pay_cumulative += to_pay
            to_keep_cumulative += to_keep

        return to_pay_cumulative, to_keep_cumulative, previous_transactions_hash_pointers, transactions_used_as_basis

    def build_new_transaction(
        self, 
        to_pay_cumulative, 
        to_keep_cumulative, 
        previous_transactions_hash_pointers,
        payer,
        receiver
        ):
        if to_keep_cumulative != 0:
            new_transaction = Transaction(
                'PayCoins',
                previous_transactions_hash_pointers,
                [to_pay_cumulative, to_keep_cumulative],
                [receiver.get_id(), payer.get_id()]
            )
        else:
            new_transaction = Transaction(
                'PayCoins',
                previous_transactions_hash_pointers,
                [to_pay_cumulative],
                [receiver.get_id()]
            )
        
        new_transaction.add_signature(payer.sign_transaction(new_transaction.generate_slip()))

        return new_transaction

    def generate_random_valid_transaction(self):
        
        # generate a payer and a receiver
        print_console_and_file('LOG: PICKING TWO RANDOM USERS FOR A VALID TRANSACTION')
        payer, receiver, payer_wallet = self.get_random_valid_wallet()
        
        # generate payment
        (to_pay_cumulative, 
         to_keep_cumulative, 
         previous_transactions_hash_pointers, 
         transactions_used_as_basis) = self.generate_payment_from_wallet(payer, payer_wallet)

        print_console_and_file('LOG: PAYER:' + str(payer.get_id().export_key()))
        print_console_and_file('LOG: PAYER WILL PAY:' + str(to_pay_cumulative))
        print_console_and_file('LOG: PAYER WILL KEEP REMNANT:' + str(to_keep_cumulative))
        print_console_and_file('LOG: TOTAL:' + str((to_pay_cumulative + to_keep_cumulative)))
        
        # generate transaction
        new_transaction = self.build_new_transaction(
            to_pay_cumulative, 
            to_keep_cumulative,
            previous_transactions_hash_pointers,
            payer,
            receiver
            )

        # add transaction to blockchain
        transaction_passed, published_new_block = self.scrooge.add_transaction(new_transaction, payer.get_id())
        if transaction_passed:
            
            new_transaction_hash_pointer = Hash_Pointer(
                new_transaction, 
                SHA512.new(new_transaction.get_signature())
                )
            
            # update payer wallet
            if to_keep_cumulative != 0:
                payer.ewallet_temp.append(new_transaction_hash_pointer)
                print_console_and_file('LOG: REMNANT TO BE ADDED TO PAYER WALLET.')
            
            for x in transactions_used_as_basis:
                payer.spent_before_temp.append(x)
            
            # update receiver wallet
            receiver.ewallet_temp.append(new_transaction_hash_pointer)

            if published_new_block:
                for user in self.users:
                    user.notify_block_published()

            print_console_and_file('LOG: TRANSACTION COMPLETE')
            return True
        else:
            print_console_and_file('ERROR: TRANSACTION FAILED')
            return False

    def double_spend(self):
                
        # generate a payer and a receiver
        print_console_and_file('LOG: PICKING TWO RANDOM USERS FOR A DOUBLE SPENDING ATTACK')
        
        # retrieve payer
        payer = None
        for user in random.sample(self.users, len(self.users)):
            if len(user.spent_before + user.spent_before_temp) != 0:
                payer = user
                break
        
        if payer is None:
            print_console_and_file('LOG: CANNOT GENERATE DOUBLE SPENDING TRANSACTION BECAUSE NO COINS HAVE BEEN SPENT YET.')
            return False, False

        # retrieve receiver
        receiver = random.sample(self.users, len(self.users))[0]
        
        # generate payment from malicious wallet
        payer_wallet = payer.spent_before + payer.spent_before_temp

        (to_pay_cumulative, 
         to_keep_cumulative, 
         previous_transactions_hash_pointers, 
         transactions_used_as_basis) = self.generate_payment_from_wallet(payer, payer_wallet)

        # generate transaction
        new_transaction = self.build_new_transaction(
            to_pay_cumulative,
            to_keep_cumulative,
            previous_transactions_hash_pointers,
            payer,
            receiver
        )

        print_console_and_file('LOG: GENERATED THE FOLLOWING DOUBLE SPENDING ATTACK:')
        print_console_and_file('LOG: PAYER:' + str(payer.get_id().export_key()))
        print_console_and_file(new_transaction.generate_slip())

        return self.scrooge.add_transaction(new_transaction, payer.get_id())
    
    def execute_fake_signature_attack(self):
        # generate a payer and a receiver
        print_console_and_file('LOG: PICKING TWO RANDOM USERS FOR A VALID TRANSACTION')
        payer, receiver, payer_wallet = self.get_random_valid_wallet()
        
        # generate payment
        (to_pay_cumulative, 
         to_keep_cumulative, 
         previous_transactions_hash_pointers, 
         transactions_used_as_basis) = self.generate_payment_from_wallet(payer, payer_wallet)
        
        # generate transaction
        new_transaction = self.build_new_transaction(
            to_pay_cumulative, 
            to_keep_cumulative,
            previous_transactions_hash_pointers,
            payer,
            receiver
            )

        print_console_and_file('LOG: ADDING A FAKE SIGNATURE.')
        fake_signature = receiver.sign_transaction(new_transaction.generate_slip())

        new_transaction.add_signature(fake_signature)

        print_console_and_file('LOG: GENERATED THE FOLLOWING FAKE SIGNATURE ATTACK:')
        print_console_and_file('LOG: PAYER:' + str(payer.get_id().export_key()))
        print_console_and_file('LOG: FAKE SIGNATURE:' + str(fake_signature))
        print_console_and_file(new_transaction.generate_slip())

        return self.scrooge.add_transaction(new_transaction, payer.get_id())
    
    def execute_fake_amount_attack(self):
        # generate a payer and a receiver
        print_console_and_file('LOG: PICKING TWO RANDOM USERS FOR A VALID TRANSACTION.')
        payer, receiver, payer_wallet = self.get_random_valid_wallet()
        
        # generate payment
        (to_pay_cumulative, 
        to_keep_cumulative, 
        previous_transactions_hash_pointers, 
        transactions_used_as_basis) = self.generate_payment_from_wallet(payer, payer_wallet)
        
        # generate transaction
        print_console_and_file('LOG: TAMPERING WITH TRANSACTION AMOUNT BY ADDING 100 TO FIRST RECEPIENT.')
        new_transaction = self.build_new_transaction(
            to_pay_cumulative + Decimal('100'), 
            to_keep_cumulative,
            previous_transactions_hash_pointers,
            payer,
            receiver
            )
        
        print_console_and_file('LOG: GENERATED THE FOLLOWING FAKE TRANSACTION AMOUNT ATTACK:')
        print_console_and_file('LOG: PAYER:' + str(payer.get_id().export_key()))
        print_console_and_file(new_transaction.generate_slip())

        return self.scrooge.add_transaction(new_transaction, payer.get_id())
    
    def execute_unowned_coins_attack(self):
        # generate a payer and a receiver
        print_console_and_file('LOG: PICKING TWO RANDOM USERS FOR A VALID TRANSACTION.')
        payer, receiver, payer_wallet = self.get_random_valid_wallet()
        
        # generate payment
        (to_pay_cumulative, 
        to_keep_cumulative, 
        previous_transactions_hash_pointers, 
        transactions_used_as_basis) = self.generate_payment_from_wallet(payer, payer_wallet)
        
        # generate transaction
        print_console_and_file('LOG: SWITCHING PAYER AND RECEIVER TO PRODUCE A TRANSACTION WITH UNOWNED COINS.')
        new_transaction = self.build_new_transaction(
            to_pay_cumulative, 
            to_keep_cumulative,
            previous_transactions_hash_pointers,
            receiver,
            payer
            )
        
        print_console_and_file('LOG: GENERATED THE FOLLOWING UNOWNED COINS ATTACK:')
        print_console_and_file('LOG: PAYER:' + str(receiver.get_id().export_key()))
        print_console_and_file(new_transaction.generate_slip())

        return self.scrooge.add_transaction(new_transaction, receiver.get_id())
    
    def execute_non_existent_coins_attack(self):
        # generate a payer and a receiver
        print_console_and_file('LOG: PICKING TWO RANDOM USERS FOR A VALID TRANSACTION.')
        payer, receiver, payer_wallet = self.get_random_valid_wallet()
        
        # generate payment
        (to_pay_cumulative, 
        to_keep_cumulative, 
        previous_transactions_hash_pointers, 
        transactions_used_as_basis) = self.generate_payment_from_wallet(payer, payer_wallet)

        print_console_and_file('LOG: TAMPERING WITH TRANSACTION AMOUNT BY ADDING NON-EXISTENT COIN.')
        previous_transactions_hash_pointers[0] = Hash_Pointer(
            previous_transactions_hash_pointers[0].get_pointer(),
            previous_transactions_hash_pointers[0].get_hash_value(),
            -1
        )
        
        # generate transaction
        new_transaction = self.build_new_transaction(
            to_pay_cumulative, 
            to_keep_cumulative,
            previous_transactions_hash_pointers,
            payer,
            receiver
            )
        
        print_console_and_file('LOG: GENERATED THE FOLLOWING NON-EXISTENT COIN ATTACK:')
        print_console_and_file('LOG: PAYER:' + str(payer.get_id().export_key()))
        print_console_and_file(new_transaction.generate_slip())

        return self.scrooge.add_transaction(new_transaction, payer.get_id())

    def execute_double_spend_unspent_coin_attack(self):
        # generate a payer and a receiver
        print_console_and_file('LOG: PICKING TWO RANDOM USERS FOR A VALID TRANSACTION.')
        payer, receiver, payer_wallet = self.get_random_valid_wallet()
        
        # generate payment
        (to_pay_cumulative, 
        to_keep_cumulative, 
        previous_transactions_hash_pointers, 
        transactions_used_as_basis) = self.generate_payment_from_wallet(payer, payer_wallet)
        
        # generate transaction
        print_console_and_file('LOG: TAMPERING WITH TRANSACTION AMOUNT BY DOUBLE-SPENDING A COIN.')
        
        trans_to_duplicate = previous_transactions_hash_pointers[0]
        previous_transactions_hash_pointers.append(
            Hash_Pointer(
                trans_to_duplicate.get_pointer(),
                trans_to_duplicate.get_hash_value(),
                trans_to_duplicate.get_coin_serial_num()
            )
        )
        to_pay_cumulative += trans_to_duplicate.get_pointer().coins_created[trans_to_duplicate.get_coin_serial_num()]['value']
        
        new_transaction = self.build_new_transaction(
            to_pay_cumulative, 
            to_keep_cumulative,
            previous_transactions_hash_pointers,
            payer,
            receiver
            )
        
        print_console_and_file('LOG: GENERATED THE FOLLOWING DOUBLE-SPEND UNSPENT COIN ATTACK:')
        print_console_and_file('LOG: PAYER:' + str(payer.get_id().export_key()))
        print_console_and_file(new_transaction.generate_slip())

        return self.scrooge.add_transaction(new_transaction, payer.get_id())

def main(): 
    with open('output.txt', 'w') as file_out:
        print('LOG: STARTING SIMULATION', file=file_out)
    
    simulator = RandomSimulator(NUMBER_OF_USERS)
    
    while True:
        print("""
            Instructions: (Enter a key, then press enter)
            1. space to exit.
            2. g to generate new VALID random transactions.
            3. p to print the user ids and balances.
            4. a to ATTACK the system.
        """)
        input_char = input('Choose action: ')

        if input_char == ' ':
            sum_acc = Decimal('0')
            for user in simulator.users:
                sum_acc += user.get_balance()[1]
            print_console_and_file('LOG: TOTAL COINS VALUES IN SYSTEM:' + str(sum_acc))
            return
        
        if input_char == 'g':
            number_of_transactions = int(input('How many transactions would you like to generate? '))
            for i in range(number_of_transactions):
                simulator.generate_random_valid_transaction()

        if input_char == 'p':
            print_console_and_file('LOG: PRINTING USERS AND THEIR BALANCES')
            for user in simulator.users:
                print_console_and_file('ID:' + str(user.get_balance()[0]))
                print_console_and_file('BALANCE:' + str(user.get_balance()[1]))
            print_console_and_file('LOG: PRINTING USERS AND THEIR BALANCES COMPLETE')
        
        if input_char == 'a':
            print("""
            Instructions:
            1. Press d, then press enter to execute a DOUBLE SPENDING attack.
            2. Press f, then press enter to execute a FAKE SIGNATURE attack.
            3. Press m, then press enter to execute a FAKE AMOUNT attack (spent money more than consumed money).
            4. Press o, then press enter to execute an UNOWNED COINS attack.
            5. Press n, then press enter to execute a NON-EXISTENT COIN attack.
            6. Press u, then press enter to execute a DOUBLE-SPEND UNSPENT COIN attack.
            """)

            attack_input = input('Which attack would you like to execute? ')
            if attack_input == 'd':
                x, y = simulator.double_spend()
            if attack_input == 'f':
                x, y = simulator.execute_fake_signature_attack()
            if attack_input == 'm':
                x, y = simulator.execute_fake_amount_attack()
            if attack_input == 'o':
                x, y = simulator.execute_unowned_coins_attack()
            if attack_input == 'n':
                x, y = simulator.execute_non_existent_coins_attack()
            if attack_input == 'u':
                x, y = simulator.execute_double_spend_unspent_coin_attack()
            
            if (not x) and (not y):
                print_console_and_file('LOG: ATTACK FAILED.')


if __name__=="__main__": 
    main()